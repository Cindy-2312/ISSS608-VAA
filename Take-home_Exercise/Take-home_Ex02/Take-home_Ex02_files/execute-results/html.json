{
  "hash": "7d297fbfd7ae045aa0a8f9d660741af0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home Exercise 02 - Minicase 1\"\nauthor: \"Cindy TA\"\n---\n\n# 1. Getting Started\n\n## 1.1. Loading R packages\nIn this take-home exercise, the 4 packages below will be used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, jsonlite,\n               tidygraph, ggraph)\n```\n:::\n\n\n# 2. Importing knowledge graph data\nFor the purpose of this exercise, MC1_graph.json file will be used. In the code chunk below, fromJSON() of jsonlite package is used to import MC1_graph.json file into R and save the output object\n\n::: {.cell}\n\n```{.r .cell-code}\nkg <- fromJSON(\"C:/Cindy-2312/ISSS608-VAA/Take-home_Exercise/MC1_release/MC1_graph.json\")\n```\n:::\n\n\n## 2.1. Inspecting the data structure\nBefore preparing the data, it is always a good practice to examine the structure of kg object.\nIn the code chunk below str() is used to reveal the structure of kg object.\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(kg, max.level = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ directed  : logi TRUE\n $ multigraph: logi TRUE\n $ graph     :List of 2\n $ nodes     :'data.frame':\t17412 obs. of  10 variables:\n $ links     :'data.frame':\t37857 obs. of  4 variables:\n```\n\n\n:::\n:::\n\n\n# 3. Extracting the edges and nodes table\nNext, as_tibble() of tibble package package is used to extract the nodes and links tibble data frames from kg object into two separate tibble data frames called nodes_tbl and edges_tbl respectively.\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes_tbl <- as_tibble(kg$nodes)\nedges_tbl <- as_tibble(kg$links) \n```\n:::\n\n\n# 3.1. Initial EDA\nIt is time for us to apply appropriate EDA methods to examine the data.\nIn this code chunk below, ggplot2 functions are used the reveal the frequency distribution of Edge Type field of edges_tbl.\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = edges_tbl,\n       aes(y = `Edge Type`)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nOn the other hands, code chunk below uses ggplot2 functions to reveal the frequency distribution of Node Type field of nodes_tbl.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = nodes_tbl,\n       aes(y = `Node Type`)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n# 4. Creating knowledge graph\n\n## 4.1. Mapping from node id to row index\nBefore we can go ahead to build the tidygraph object, it is important for us to ensure each id from the node list is mapped to the correct row number. This requirement can be achieved by using the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nid_map <- tibble(id = nodes_tbl$id,\n                 index = seq_len(\n                   nrow(nodes_tbl)))\n```\n:::\n\n\n## 4.2. Map source and target IDs to row indices\nNext, we will map the source and the target IDs to row indices by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_tbl <- edges_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>%\n  rename(from = index) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>%\n  rename(to = index)\n```\n:::\n\n\n## 4.3. Filter out any unmatched (invalid) edges\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_tbl <- edges_tbl %>%\n  filter(!is.na(from), !is.na(to))\n```\n:::\n\n\n## 4.4. Creating tidygraph()\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- tbl_graph(nodes = nodes_tbl, \n                   edges = edges_tbl, \n                   directed = kg$directed)\nclass(graph)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_graph\" \"igraph\"   \n```\n\n\n:::\n:::\n\n# 5. Visualizing the knowledge graph\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n## 5.1. Visualising the whole graph\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3, \n                 colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), \n                  size = 4) +\n  geom_node_text(aes(label = name), \n                 repel = TRUE, \n                 size = 2.5) +\n  theme_void()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: ggrepel: 17411 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n## 5.2. Visualising the sub-graph\nIn this section, we are interested to create a sub-graph base on MemberOf value in Edge Type column of the edges data frame.\n\n### Filtering edges to only “MemberOf”\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_memberof <- graph %>%\n  activate(edges) %>%\n  filter(`Edge Type` == \"MemberOf\")\n```\n:::\n\n\n### Extracting only connected nodes (i.e., used in these edges)\n\n::: {.cell}\n\n```{.r .cell-code}\nused_node_indices <- graph_memberof %>%\n  activate(edges) %>%\n  as_tibble() %>%\n  select(from, to) %>%\n  unlist() %>%\n  unique()\n```\n:::\n\n\n### Keeping only those nodes\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_memberof <- graph_memberof %>%\n  activate(nodes) %>%\n  mutate(row_id = row_number()) %>%\n  filter(row_id %in% used_node_indices) %>%\n  select(-row_id)  # optional cleanup\n```\n:::\n\n\n### Plotting the sub-graph\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph_memberof, \n       layout = \"fr\") +\n  geom_edge_link(alpha = 0.5, \n                 colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), \n                  size = 1) +\n  geom_node_text(aes(label = name), \n                 repel = TRUE, \n                 size = 2.5) +\n  theme_void()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: ggrepel: 790 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "Take-home_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}